import hashlib
from datetime import datetime
from typing import List, Dict, Set, Optional
from pydantic import BaseModel, Field
from enum import Enum

class VulnerabilityType(str, Enum):
    VULNERABILITY = "vulnerability"
    EXPLOIT = "exploit"

class Vulnerability(BaseModel):
    """
    Standardized vulnerability/exploit data model for all sources.
    Uses MD5-based IDs for consistency across all scrapers.
    """
    # Core identification
    id: str  # MD5(path_url) - Unique identifier across all sources
    content_hash: str  # MD5(content) - For duplicate detection
    
    # Source information
    path_url: str  # Original URL/path where this was found
    source: str  # Source name (e.g., "packetstorm", "enisa", "opencve")
    source_id: Optional[str] = None  # Source-specific ID (e.g., "EUVD-2024-001", "PACKETSTORM-123")
    
    # Content
    content: Optional[str] = None  # Raw content/text if available
    
    # Classification
    type: VulnerabilityType = VulnerabilityType.VULNERABILITY  # "vulnerability" or "exploit"
    cve_id: Optional[str] = None  # CVE ID if found
    
    # Metadata
    title: str
    description: str
    severity: Optional[str] = None  # HIGH, MEDIUM, LOW, CRITICAL
    cvss_score: Optional[str] = None
    cvss_vector: Optional[str] = None
    cvss_version: Optional[str] = None  # CVSS version (e.g., "3.1", "4.0")
    
    # ENISA-specific fields
    aliases: Optional[str] = None  # CVE aliases and other identifiers (newline-separated)
    assigner: Optional[str] = None  # Who assigned/published the vulnerability (e.g., "VulDB", "OpenHarmony")
    epss_score: Optional[float] = None  # EPSS probability score (0-100)
    
    # Dates
    published_at: str  # When it was published/discovered
    updated_at: Optional[str] = None  # When it was last updated
    scraped_at: str = Field(default_factory=lambda: datetime.now().isoformat())
    
    # References and components
    reference_urls: Set[str] = Field(default_factory=set)
    affected_products: Set[str] = Field(default_factory=set)
    affected_versions: Set[str] = Field(default_factory=set)
    patched_versions: Set[str] = Field(default_factory=set)
    affected_vendors: Set[str] = Field(default_factory=set)  # Vendor names
    
    # Classification tags
    tags: Set[str] = Field(default_factory=set)
    weaknesses: Set[str] = Field(default_factory=set)  # CWE identifiers
    
    # Package information (for software vulnerabilities)
    package: Optional[Dict[str, str]] = None  # {"name": "package", "ecosystem": "npm"}
    
    # Product/Vendor details (ENISA-specific)
    product_details: Optional[List[Dict[str, str]]] = None  # Product info with IDs and versions
    vendor_details: Optional[List[Dict[str, str]]] = None   # Vendor info with IDs
    
    # Exploit-specific fields (ExploitDB-specific)
    exploit_type: Optional[str] = None  # Type of exploit (e.g., "remote", "local", "dos")
    exploit_file_path: Optional[str] = None  # Path to exploit file in repository
    
    @classmethod
    def create_id(cls, path_url: str) -> str:
        """Generate MD5 ID from path URL."""
        return hashlib.md5(path_url.encode('utf-8')).hexdigest()
    
    @classmethod
    def create_content_hash(cls, content: str) -> str:
        """Generate MD5 hash from content."""
        if not content:
            return ""
        return hashlib.md5(content.encode('utf-8')).hexdigest()
    
    @classmethod
    def from_path_and_content(cls, path_url: str, content: str = "", **kwargs) -> 'Vulnerability':
        """Create vulnerability with auto-generated IDs."""
        return cls(
            id=cls.create_id(path_url),
            content_hash=cls.create_content_hash(content),
            path_url=path_url,
            content=content,
            **kwargs
        )
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for storage."""
        return {
            "id": self.id,
            "content_hash": self.content_hash,
            "path_url": self.path_url,
            "source": self.source,
            "source_id": self.source_id,
            "content": self.content,
            "type": self.type.value,
            "cve_id": self.cve_id,
            "title": self.title,
            "description": self.description,
            "severity": self.severity,
            "cvss_score": self.cvss_score,
            "cvss_vector": self.cvss_vector,
            "cvss_version": self.cvss_version,
            "aliases": self.aliases,
            "assigner": self.assigner,
            "epss_score": self.epss_score,
            "published_at": self.published_at,
            "updated_at": self.updated_at,
            "scraped_at": self.scraped_at,
            "reference_urls": list(self.reference_urls),
            "affected_products": list(self.affected_products),
            "affected_versions": list(self.affected_versions),
            "patched_versions": list(self.patched_versions),
            "affected_vendors": list(self.affected_vendors),
            "tags": list(self.tags),
            "weaknesses": list(self.weaknesses),
            "package": self.package,
            "product_details": self.product_details,
            "vendor_details": self.vendor_details
        }
